// Class automatically generated by Dev-C++ New Class wizard

#include "keyinputapi.h" // class's header file

ki::KeyState ki::KeyInputAPI::GetKeyState(KeyType key) {
    // Return all-false Key state if Window is not active
    if (!isWindowActive)
        return KeyState(key);
    
    // Find previous key state
    bool prevDown = false;
    if (!pressed.empty()) { 
        vector<int>::iterator iter(pressed.begin());
        for ( ; iter != pressed.end(); iter++) {
            if (*iter == key) {
                prevDown = true;
                break;
            }
        }
    }
    
    // Get key state
    KeyState state(key);
    state.lShift    = GetAsyncKeyState(VK_LSHIFT) & 0x8000;
    state.rShift    = GetAsyncKeyState(VK_RSHIFT) & 0x8000;
    state.lControl  = GetAsyncKeyState(VK_LCONTROL) & 0x8000;
    state.rControl  = GetAsyncKeyState(VK_RCONTROL) & 0x8000;
    state.lAlt      = GetAsyncKeyState(VK_LMENU) & 0x8000;
    state.rAlt      = GetAsyncKeyState(VK_RMENU) & 0x8000;
    state.shift     = state.lShift   || state.rShift;
    state.control   = state.lControl || state.rControl;
    state.alt       = state.lAlt     || state.rAlt;
    state.down      = GetAsyncKeyState(key) & 0x8000;
    state.pressed   = (GetAsyncKeyState(key) & 0x8000) && !prevDown;
    
    // Add to previously pressed vector
    if (state.pressed)
        pressed.push_back(key);
    
    return state;
}

void ki::KeyInputAPI::UpdateKeyState() {
    // Stop update key state if Window is not active (or nothing to update)
    if (!isWindowActive || pressed.empty())
        return;
        
    vector<int>::iterator iter(pressed.begin());
    for ( ; iter != pressed.end(); ) {
        short state = GetAsyncKeyState(*iter);
        if (state & 0x8000)
            ++iter;
        else
            iter = pressed.erase(iter);
    }
}
